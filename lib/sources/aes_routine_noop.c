#include "tcl.h"

#include "aes_defines.h"
#include "aes_routine_noop.h"

static uint8_t sBox[] = {   // Substitution table (S-box), used for subByte() transformation.
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };

static uint8_t inv_sBox[] = {
    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };

static uint8_t Rcon[] = {   // Round constant word array.
    0x01, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00,
    0x08, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00,
    0x80, 0x00, 0x00, 0x00,
    0x1b, 0x00, 0x00, 0x00,
    0x36, 0x00, 0x00, 0x00 };

void subByte(uint8_t* src, uint8_t* dst)
{
    *dst = sBox[(((*src) & 0xF0) >> 4) * 16 + ((*src) & 0x0F)];
};

void subWord(uint32_t* src, uint32_t* dst)
{
    *((uint8_t*)dst + 0) = sBox[(((*((uint8_t*)src + 0)) & 0xF0) >> 4) * 16 + (*((uint8_t*)src + 0) & 0x0F)];
    *((uint8_t*)dst + 1) = sBox[(((*((uint8_t*)src + 1)) & 0xF0) >> 4) * 16 + (*((uint8_t*)src + 1) & 0x0F)];
    *((uint8_t*)dst + 2) = sBox[(((*((uint8_t*)src + 2)) & 0xF0) >> 4) * 16 + (*((uint8_t*)src + 2) & 0x0F)];
    *((uint8_t*)dst + 3) = sBox[(((*((uint8_t*)src + 3)) & 0xF0) >> 4) * 16 + (*((uint8_t*)src + 3) & 0x0F)];
};
 
void rotWord(uint32_t* src, uint32_t* dst)
{
    uint8_t tmp = *((uint8_t*)src + 0);
    *((uint8_t*)dst + 0) = *((uint8_t*)src + 1);
    *((uint8_t*)dst + 1) = *((uint8_t*)src + 2);
    *((uint8_t*)dst + 2) = *((uint8_t*)src + 3);
    *((uint8_t*)dst + 3) = tmp;
};

uint32_t rcon(uint32_t n)
{
    return *((uint32_t*)Rcon + n);
};

void addRoundKey(uint32_t* state, uint32_t* w, uint32_t round)
{
    for (uint32_t i = 0; i < NB; i++)
    {
        state[i] = state[i] ^ w[round * NB + i];
    }   
};

void subBytes(uint32_t* state)
{
    for (uint32_t i = 0; i < NB; i++)
    {
        subWord(state + i, state + i);
    }
};

void shiftRows(uint32_t* state)
{
    uint32_t tmpState[4];

    uint8_t* from = (uint8_t*)(state);
    uint8_t* to = (uint8_t*)(tmpState);

    to[0]  = from[0];
    to[1]  = from[5];
    to[2]  = from[10];
    to[3]  = from[15];
    to[4]  = from[4];
    to[5]  = from[9];
    to[6]  = from[14];
    to[7]  = from[3];
    to[8]  = from[8];
    to[9]  = from[13];
    to[10] = from[2];
    to[11] = from[7];
    to[12] = from[12];
    to[13] = from[1];
    to[14] = from[6];
    to[15] = from[11];

    for (uint32_t i = 0; i < NB; i++)
    {
        state[i] = tmpState[i];
    }
};

// The following two functions are implementing some polynomial arithmetic.

// This function perform the carry-less multiplication of two 8 bit values.
// In this scope, the carry-less multiplication is used in polynomial multiplication.
uint16_t clMul(uint8_t multiplicand, uint8_t multiplier)
{
    uint16_t product = 0;
    uint8_t* pProduct = (uint8_t*)(&product);

    for(uint8_t i = 0; i < 8; i++ )
    {
        uint8_t lo = 0;
        uint8_t hi = 0;

        if((multiplier >> i) & 1)
        {
            lo = multiplicand << i;
            hi = multiplicand >> (8 - i);

            pProduct[0] = pProduct[0] ^ hi;
            pProduct[1] = pProduct[1] ^ lo;
        }
    }

    return product;
};

// This function perform the modular reduction by polynomial modulo [x^8 + x^4 + x^3 + x + 1].
uint8_t polyMod(uint16_t value)
{
    uint8_t digitMaskUnc = 0x80;
    uint8_t hiMaskUnc = 0x8D;
    uint8_t loMaskUnc = 0x80;

    uint8_t* pValue = (uint8_t*)(&value);

    for(uint8_t i = 0; i < 8; i++ )
    {
        uint8_t hiMask = hiMaskUnc >> i;
        uint8_t loMask = (loMaskUnc >> i) | (hiMaskUnc << (8 - i));
        uint8_t digitMask = digitMaskUnc >> i;

        if(pValue[0] & digitMask)
        {
           pValue[0] = pValue[0] ^  hiMask;
           pValue[1] = pValue[1] ^  loMask;
        } 
    }

    return pValue[1];
};

// Polynomial multiplication 
#define polyMul(a, b) polyMod(clMul(a, b))

void mixColumn(uint32_t* column)
{
    uint32_t tmp = *column;
    uint8_t* src = (uint8_t*)(&tmp);
    uint8_t* dst = (uint8_t*)(column);

    dst[0] = polyMul(0x02, src[0]) ^ polyMul(0x03, src[1]) ^ src[2] ^ src[3];
    dst[1] = src[0] ^ polyMul(0x02, src[1]) ^ polyMul(0x03, src[2]) ^ src[3];
    dst[2] = src[0] ^ src[1] ^ polyMul(0x02, src[2]) ^ polyMul(0x03, src[3]);
    dst[3] = polyMul(0x03, src[0]) ^ src[1] ^ src[2] ^ polyMul(0x02, src[3]);
}

void mixColumns(uint32_t* state)
{
    for (uint32_t i = 0; i < NB; i++)
    {
        mixColumn(state + i);
    }
}

void invShiftRows(uint32_t* state)
{
    uint32_t tmpState[4];

    uint8_t* from = (uint8_t*)(state);
    uint8_t* to = (uint8_t*)(tmpState);

    to[0]  = from[0];
    to[1]  = from[13];
    to[2]  = from[10];
    to[3]  = from[7];
    to[4]  = from[4];
    to[5]  = from[1];
    to[6]  = from[14];
    to[7]  = from[11];
    to[8]  = from[8];
    to[9]  = from[5];
    to[10] = from[2];
    to[11] = from[15];
    to[12] = from[12];
    to[13] = from[9];
    to[14] = from[6];
    to[15] = from[3];

    for (uint32_t i = 0; i < NB; i++)
    {
        state[i] = tmpState[i];
    }
};

void invSubWord(uint32_t* src, uint32_t* dst)
{
    *((uint8_t*)dst + 0) = inv_sBox[(((*((uint8_t*)src + 0)) & 0xF0) >> 4) * 16 + (*((uint8_t*)src + 0) & 0x0F)];
    *((uint8_t*)dst + 1) = inv_sBox[(((*((uint8_t*)src + 1)) & 0xF0) >> 4) * 16 + (*((uint8_t*)src + 1) & 0x0F)];
    *((uint8_t*)dst + 2) = inv_sBox[(((*((uint8_t*)src + 2)) & 0xF0) >> 4) * 16 + (*((uint8_t*)src + 2) & 0x0F)];
    *((uint8_t*)dst + 3) = inv_sBox[(((*((uint8_t*)src + 3)) & 0xF0) >> 4) * 16 + (*((uint8_t*)src + 3) & 0x0F)];
};

void invSubBytes(uint32_t* state)
{
    for (uint32_t i = 0; i < NB; i++)
    {
        invSubWord(state + i, state + i);
    }
};

void invMixColumn(uint32_t* column)
{
    uint32_t tmp = *column;
    uint8_t* src = (uint8_t*)(&tmp);
    uint8_t* dst = (uint8_t*)(column);

    dst[0] = polyMul(0x0e, src[0]) ^ polyMul(0x0b, src[1]) ^ polyMul(0x0d, src[2]) ^ polyMul(0x09, src[3]);
    dst[1] = polyMul(0x09, src[0]) ^ polyMul(0x0e, src[1]) ^ polyMul(0x0b, src[2]) ^ polyMul(0x0d, src[3]);
    dst[2] = polyMul(0x0d, src[0]) ^ polyMul(0x09, src[1]) ^ polyMul(0x0e, src[2]) ^ polyMul(0x0b, src[3]);
    dst[3] = polyMul(0x0b, src[0]) ^ polyMul(0x0d, src[1]) ^ polyMul(0x09, src[2]) ^ polyMul(0x0e, src[3]);
}

void invMixColumns(uint32_t* state)
{
    for (uint32_t i = 0; i < NB; i++)
    {
        invMixColumn(state + i);
    }
}
